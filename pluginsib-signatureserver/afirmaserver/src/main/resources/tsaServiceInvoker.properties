# Copyright (C) 2012-13 MINHAP, Gobierno de España
# This program is licensed and may be used, modified and redistributed under the terms
# of the European Public License (EUPL), either version 1.1 or (at your
# option) any later version as soon as they are approved by the European Commission.
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and
# more details.
# You should have received a copy of the EUPL1.1 license
# along with this program; if not, you may find it at
# http://joinup.ec.europa.eu/software/page/eupl/licence-eupl


#PROPIEDADES COMUNES PARA INVOCAR LOS SERVICIOS DE TS@

#Ruta al almacen de confianza (JKS) para conexiones seguras.
com.trustedstorePath =

#Contraseña del almacén de confianza (JKS) para conexiones seguras.
com.trustedstorePassword =


#PROPIEDADES COMUNES PARA INVOCAR LOS SERVICIOS WEB DE TS@

#Ruta al fichero descriptor con los servicios web
com.serviceWSDLPath =C:/Users/Jesus.munoz/Desktop/TimeStampWS.wsdl


#PROPIEDADES ESPECÍFICAS DE CADA APLICACIÓN PARA INVOCAR LOS SERVICIOS WEB DE TS@

#Tiempo de vida para las peticiones SOAP, en milisegundos.
appTSA.callTimeout =10000

#Modo de validación para los sellos de tiempo que vayan a ser renovados. Los valores permitidos son:
#	0 -> Sin validación. Este modo va a en contra del estándar definido por OASIS que establece que en una operación de renovación 
#						 de sello de tiempo el cliente debe validar el sello de tiempo previamente.
# 	1 -> Validación de la integridad
#	2 -> Validación completa (Se realizará invocación al servicio de validación de sello de tiempo WS de TS@)
appTSA.renewTimeStampWS.validationLevel = 0

#Tipo de autenticación para la petición SOAP:
#UserNameToken: Autorización por usuario/contraseña.
#X509CertificateToken: Autorización por certificado.
#SAMLToken: Autorización por SAML
appTSA.authorizationMethod =X509CertificateToken

# ---------- INICIO AUTENTICACIÓN UserNameToken ----------
#Nombre de usuario para el caso de autenticación por usuario/contraseña para la petición SOAP.
appTSA.UserNameToken.userName =

#Contraseña de usuario para el caso de autenticación por usuario/contraseña para la petición SOAP.
appTSA.UserNameToken.userPassword =
# ---------- FIN AUTENTICACIÓN UserNameToken ----------

# ---------- INICIO AUTENTICACIÓN X509CertificateToken ----------
#Mecanismo de inclusión del certificado para el caso de autorización por certificado para la petición SOAP:
#Direct: Binary Security Token
#Identifier: Key Identifier
#IssuerSerialNumber: Issuer and Serial Number
appTSA.X509CertificateToken.inclusionMethod =Direct

#Ruta al almacén de claves donde se encuentra almacenada la clave privada a usar para firmar la petición SOAP en el caso de autenticación por certificado.
appTSA.X509CertificateToken.keystorePath =C:/Users/Jesus.munoz/JMunoz/Desarrollos/AfirmaCerts-2012-2015/P12/SoapSigner-2012.p12

#Tipo de almacén de claves donde se encuentra almacenada la clave privada a usar para firmar la petición SOAP en el caso de autenticación por certificado:
#PKCS12
#JKS
#JCEKS
appTSA.X509CertificateToken.keystoreType =PKCS12

#Contraseña del almacén de claves donde se encuentra almacenada la clave privada a usar para firmar la petición SOAP en el caso de autenticación por certificado.
appTSA.X509CertificateToken.keystorePassword =12345

#Alias de la clave privada a usar para firmar la petición SOAP en el caso de autenticación por certificado.
appTSA.X509CertificateToken.privateKeyAlias =soapsigner

#Contraseña de la clave privada a usar para firmar la petición SOAP en el caso de autenticación por certificado.
appTSA.X509CertificateToken.privateKeyPassword =12345
# ---------- FIN AUTENTICACIÓN X509CertificateToken ----------

# ---------- INICIO AUTENTICACIÓN SAMLToken ----------
#Método de confirmación del sujeto para el caso de autorización por SAML:
#HOK: Holder-of-Key
#SV: Sender-Vouches
appTSA.SAMLToken.method =

#Ruta al almacén de claves donde se encuentra almacenada la clave privada a usar para firmar la petición SOAP en el caso de autenticación por SAML.
appTSA.SAMLToken.keystorePath =

#Tipo de almacén de claves donde se encuentra almacenada la clave privada a usar para firmar la petición SOAP en el caso de autenticación por SAML:
#PKCS12
#JKS
#JCEKS
appTSA.SAMLToken.keystoreType =

#Contraseña del almacén de claves donde se encuentra almacenada la clave privada a usar para firmar la petición SOAP en el caso de autenticación por SAML.
appTSA.SAMLToken.keystorePassword =

#Alias de la clave privada a usar para firmar la petición SOAP en el caso de autenticación por SAML.
appTSA.SAMLToken.privateKeyAlias =

#Contraseña de la clave privada a usar para firmar la petición SOAP en el caso de autenticación por SAML.
appTSA.SAMLToken.privateKeyPassword =
# ---------- FIN AUTENTICACIÓN SAMLToken ----------

# ---------- INICIO CIFRADO PETICIÓN CON CLAVE SIMÉTRICA ----------
#Indicador para cifrar las peticiones SOAP con clave simétrica o no:
#true: Las peticiones SOAP irán cifradas.
#false: Las peticiones SOAP no irán cifradas.
appTSA.request.symmetricKey.use =false

#Alias de la clave simétrica a usar para cifrar las peticiones SOAP.
appTSA.request.symmetricKey.alias =

#Valor de la clave simétrica, en hexadecimal, a usar para cifrar las peticiones SOAP.
appTSA.request.symmetricKey.value =

# ---------- FIN CIFRADO PETICIÓN CON CLAVE SIMÉTRICA ----------

# ---------- INICIO AUTENTICACIÓN RESPUESTA FIRMADA ----------
#Ruta al almacén de claves donde se encuentra almacenado el certificado a usar para validar las respuestas SOAP que se encuentren firmadas.
appTSA.response.keystorePath =

#Tipo de almacén de claves donde se encuentra almacenado el certificado a usar para validar las respuestas SOAP que se encuentren firmadas.
#PKCS12
#JKS
#JCEKS
appTSA.response.keystoreType =

#Contraseña del almacén de claves donde se encuentra almacenado el certificado a usar para validar las respuestas SOAP que se encuentren firmadas.
appTSA.response.keystorePassword =

#Alias del certificado a usar para validar las respuestas SOAP que se encuentren firmadas.
appTSA.response.certificateAlias =

# ---------- FIN AUTENTICACIÓN RESPUESTA FIRMADA ----------

# ---------- INICIO AUTENTICACIÓN RESPUESTA SAML ----------
#Ruta al almacén de claves donde se encuentra almacenado el certificado a usar para validar las respuestas SOAP aseguradas con SAML.
appTSA.response.SAML.keystorePath =

#Tipo de almacén de claves donde se encuentra almacenado el certificado a usar para validar las respuestas SOAP aseguradas con SAML.
#PKCS12
#JKS
#JCEKS
appTSA.response.SAML.keystoreType =

#Contraseña del almacén de claves donde se encuentra almacenado el certificado a usar para validar las respuestas SOAP aseguradas con SAML.
appTSA.response.SAML.keystorePassword =

#Alias del certificado a usar para validar las respuestas SOAP aseguradas con SAML.
appTSA.response.SAML.certificateAlias =

# ---------- FIN AUTENTICACIÓN RESPUESTA SAML ----------

# ---------- INICIO DESCIFRADO RESPUESTA CON CLAVE SIMÉTRICA ----------
#Alias de la clave simétrica a usar para descifrar las respuestas SOAP cifradas con clave simétrica.
appTSA.response.symmetricKey.alias =

#Valor de la clave simétrica a usar para descifrar las respuestas SOAP cifradas con clave simétrica.
appTSA.response.symmetricKey.value =



#PROPIEDADES ESPECÍFICAS DE CADA APLICACIÓN PARA INVOCAR LOS SERVICIOS RFC 3161 DE TS@

#Dirección host donde se encuentra desplegado el servicio RFC 3161.
appTSA.rfc3161.host =

#OID de la política de sello de tiempo a indicar en la petición.
appTSA.rfc3161.timestampPolicyOID =

#OID de la aplicación a indicar en la petición
appTSA.rfc3161.applicationOID = 1.3.4.6.1.3.4.6

#Tiempo de vida para las peticiones al servicio RFC 3161, en milisegundos.
appTSA.rfc3161.Timeout =

#Algoritmo de resumen que aplicar sobre los datos a sellar:
#SHA
#SHA-256
#SHA-512
#RIPEMD-160
appTSA.rfc3161.shaAlgorithm =


# ---------- INICIO SERVICIO RFC 3161 (TCP) ----------

#Número del puerto donde se encuentra desplegado el servicio RFC 3161.
appTSA.rfc3161.portNumber =

# ---------- INICIO SERVICIO RFC 3161 (TCP) ----------


# ---------- INICIO SERVICIO RFC 3161 (HTTPS) ----------

#Número del puerto donde se encuentra desplegado el servicio RFC 3161 - HTTPS.
appTSA.rfc3161HTTPS.portNumber =

#Contexto para la conexión con el servicio RFC 3161 por HTTPS.
appTSA.rfc3161HTTPS.context =

#Indicador para utilizar autenticación HTTPS mediante certificado cliente o no:
#true: El cliente se autentica mediante certificado.
#false: El cliente no requiere de autenticación mediante certificado.
appTSA.rfc3161HTTPS.useAuthClient =

#Ruta al almacén de claves donde se encuentra almacenada la clave privada a usar para la autenticación HTTPS del cliente por certificado.
appTSA.rfc3161HTTPS.keystorePath =

#Tipo de almacén de claves donde se encuentra almacenada la clave privada a usar para la autenticación HTTPS del cliente por certificado:
#PKCS12
#JKS
#JCEKS
appTSA.rfc3161HTTPS.keystoreType =

#Contraseña del almacén de claves donde se encuentra almacenada la clave privada a usar para la autenticación HTTPS del cliente por certificado.
appTSA.rfc3161HTTPS.keystorePassword =

# ---------- INICIO SERVICIO RFC 3161 (HTTPS) ----------


# ---------- INICIO SERVICIO RFC 3161 (SSL) ----------

#Número del puerto donde se encuentre desplegado el servicio RFC 3161 que permite autenticación por SSL.
appTSA.rfc3161SSL.portNumber =

#Ruta al almacén de claves donde se encuentra almacenada la clave privada a usar para la autenticación por SSL.
appTSA.rfc3161SSL.keystorePath =

#Tipo de almacén de claves donde se encuentra almacenada la clave privada a usar para la autenticación por SSL:
#PKCS12
#JKS
#JCEKS
appTSA.rfc3161SSL.keystoreType =

#Contraseña del almacén de claves donde se encuentra almacenada la clave privada a usar para la autenticación por SSL.
appTSA.rfc3161SSL.keystorePassword =

# ---------- INICIO SERVICIO RFC 3161 (SSL) ----------